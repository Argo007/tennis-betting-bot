name: Basketball Picks (WNBA debug -> proves pipeline)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *"

jobs:
  picks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests

      - name: WNBA odds test (with robust fallback + debug)
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python << 'PY'
          import os, requests, pandas as pd, datetime as dt, json, sys

          API = os.getenv("ODDS_API_KEY")
          if not API:
              raise SystemExit("ERROR: set ODDS_API_KEY in repo Settings → Secrets → Actions")

          SPORT = "basketball_wnba"     # live league now; swap to NBA/EuroLeague later
          REGIONS = "us,eu"
          # Official filters
          FAV_MIN, FAV_MAX = 1.25, 1.80
          DOG_MIN, DOG_MAX = 2.20, 4.50
          MIN_KELLY, KELLY_CAP = 0.03, 0.25

          def ip(o):
              o = float(o); return 1.0/o if o > 1.0 else None
          def evk(p,o):
              o = float(o); ev = o*p - (1-p); b = o-1.0
              k = ((b*p)-(1-p))/b if b>0 else 0.0
              return ev, max(0.0, min(KELLY_CAP, k))

          def get(url, **params):
              r = requests.get(url, params=params, timeout=30)
              if r.status_code in (200, 404): return r
              r.raise_for_status(); return r

          # --- DEBUG: list sports we can see
          s = get("https://api.the-odds-api.com/v4/sports", apiKey=API, all="true")
          sports = s.json() if s.status_code==200 else []
          dbg = [f"Sports visible: {len(sports)}. Key present: {any(sp.get('key')==SPORT for sp in sports)}"]

          # --- Try odds WITHOUT time filters first (many books ignore time range)
          r = get(f"https://api.the-odds-api.com/v4/sports/{SPORT}/odds",
                  apiKey=API, regions=REGIONS, markets="h2h", oddsFormat="decimal")
          odds = r.json() if r.status_code==200 else []
          dbg.append(f"Odds (no time filters) events: {len(odds)} status={r.status_code}")

          # --- If empty, try with a big window to be safe
          if not odds:
              now = dt.datetime.utcnow().replace(microsecond=0).isoformat()+"Z"
              to  = (dt.datetime.utcnow()+dt.timedelta(days=14)).replace(microsecond=0).isoformat()+"Z"
              r2 = get(f"https://api.the-odds-api.com/v4/sports/{SPORT}/odds",
                       apiKey=API, regions=REGIONS, markets="h2h", oddsFormat="decimal",
                       commenceTimeFrom=now, commenceTimeTo=to)
              odds = r2.json() if r2.status_code==200 else []
              dbg.append(f"Odds (14d window) events: {len(odds)} status={r2.status_code}")

          # --- Also hit /events to see schedule even if books have no prices yet
          evr = get(f"https://api.the-odds-api.com/v4/sports/{SPORT}/events", apiKey=API)
          events = evr.json() if evr.status_code==200 else []
          dbg.append(f"Events endpoint: {len(events)} status={evr.status_code}")

          def rows_from_odds(raw, league_label):
              rows=[]
              for ev in raw:
                  home, away = ev.get("home_team"), ev.get("away_team")
                  if not home or not away: continue
                  probs, best = {}, {}
                  for bk in ev.get("bookmakers", []):
                      for m in bk.get("markets", []):
                          if m.get("key")!="h2h": continue
                          for oc in m.get("outcomes", []):
                              nm, price = oc.get("name"), oc.get("price")
                              if not nm or not price: continue
                              p = ip(price)
                              if p is None: continue
                              probs.setdefault(nm, []).append(p)
                              best[nm] = max(best.get(nm, 0.0), float(price))
                  if home not in probs or away not in probs: continue
                  avg = {k: sum(v)/len(v) for k,v in probs.items()}
                  s = sum(avg.values()); 
                  if s>0: avg = {k:v/s for k,v in avg.items()}
                  for team,opp in [(home,away),(away,home)]:
                      p = avg.get(team); o = best.get(team,0.0)
                      if not p or o<=1.0: continue
                      evu, k = evk(p,o)
                      rows.append({
                          "league": league_label,
                          "commence_time_utc": ev.get("commence_time"),
                          "team": team, "opponent": opp,
                          "best_odds": o, "blended_prob": p,
                          "ev_per_unit": evu, "kelly_fraction": k
                      })
              return rows

          # Build DF from odds
          df = pd.DataFrame(rows_from_odds(odds, "WNBA"))
          summary_lines = [f"**DEBUG**: " + " | ".join(dbg), ""]

          if df.empty:
              # If no odds but we do have events, show them so we know games exist
              if events:
                  import itertools
                  rows = []
                  for e in events:
                      t1, t2 = e.get("home_team"), e.get("away_team")
                      rows.append({"commence_time_utc": e.get("commence_time"), "home": t1, "away": t2})
                  evdf = pd.DataFrame(rows)
                  md = "_Books returned no h2h odds yet, but events exist._\n\n" \
                       "| commence_time_utc | home | away |\n|---|---|---|\n" + \
                       "\n".join("| " + " | ".join(map(str,row)) + " |" for row in evdf.values[:10])
                  summary_lines += ["## WNBA Picks (OFFICIAL)", 
                                    "**🏆 Top Favorite:** _None_", "**🏆 Top Underdog:** _None_",
                                    "\n**Favorites (EV-sorted)**\n_None_",
                                    "\n**Underdogs (EV-sorted)**\n_None_\n",
                                    md]
              else:
                  summary_lines += ["_No odds or events returned by the API right now._"]
          else:
              # Coerce numeric
              for c in ["best_odds","blended_prob","ev_per_unit","kelly_fraction"]:
                  df[c] = pd.to_numeric(df[c], errors="coerce")
              df = df.dropna(subset=["best_odds","blended_prob","ev_per_unit"])

              # dedupe per game (higher EV)
              df["match_id"] = df.apply(lambda r: " :: ".join(sorted([str(r["team"]), str(r["opponent"])])), axis=1)
              df = df.sort_values("ev_per_unit", ascending=False).groupby("match_id", as_index=False).head(1)

              def shortlist(sub, lo, hi):
                  return sub[(sub["ev_per_unit"]>0) &
                             (sub["kelly_fraction"]>=MIN_KELLY) &
                             (sub["best_odds"].between(lo,hi))]\
                        .sort_values(["ev_per_unit","blended_prob"], ascending=False)

              favs = shortlist(df, FAV_MIN, FAV_MAX)
              dogs = shortlist(df, DOG_MIN, DOG_MAX)

              def star(lbl, d):
                  if d.empty: return f"**🏆 {lbl}:** _None_"
                  r = d.iloc[0]
                  return (f"**🏆 {lbl}:** {r.team} vs {r.opponent} @ {r.best_odds:.2f} "
                          f"(p={r.blended_prob:.2f}, EV/u={r.ev_per_unit:.2f}, Kelly={r.kelly_fraction:.2f})")

              def tbl(d):
                  if d.empty: return "_None_"
                  cols=["commence_time_utc","team","opponent","best_odds","blended_prob","ev_per_unit","kelly_fraction"]
                  t=d[cols].round({"best_odds":2,"blended_prob":2,"ev_per_unit":2,"kelly_fraction":2})
                  head="| "+" | ".join(cols)+" |\n|"+" | ".join(["---"]*len(cols))+"|\n"
                  body="\n".join("| "+" | ".join(map(str,row))+" |" for row in t.values)
                  return head+body

              summary_lines += [
                  "## WNBA Picks (OFFICIAL)",
                  star("Top Favorite", favs),
                  star("Top Underdog", dogs),
                  "\n**Favorites (EV-sorted)**\n", tbl(favs.head(5)),
                  "\n**Underdogs (EV-sorted)**\n", tbl(dogs.head(5)),
              ]

              if favs.empty or dogs.empty:
                  nm = df.sort_values("ev_per_unit", ascending=False).head(5)
                  cols=["commence_time_utc","team","opponent","best_odds","blended_prob","ev_per_unit","kelly_fraction"]
                  nm = nm[cols].round({"best_odds":2,"blended_prob":2,"ev_per_unit":2,"kelly_fraction":2})
                  head="| "+" | ".join(cols)+" |\n|"+" | ".join(["---"]*len(cols))+"|\n"
                  body="\n".join("| "+" | ".join(map(str,row))+" |" for row in nm.values)
                  summary_lines += ["\n> _Near-misses (info only):_\n", head+body]

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write("\n".join(summary_lines))
          PY
