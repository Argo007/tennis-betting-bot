name: CourtSense Edge Picks

on:
  schedule:
    - cron: "0 8 * * *"   # 08:00 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: courtsense-edge-picks
  cancel-in-progress: true

env:
  TZ: Europe/Amsterdam

jobs:
  picks:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # keep setup-python cache happy
      - name: Prepare dependencies
        run: |
          printf "pandas\nrequests\npytz\n" > requirements.txt

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: "requirements.txt"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # --- build Elo (last 2â€“3 seasons) ---
      - name: Download ATP/WTA results
        run: |
          set -euo pipefail
          mkdir -p matches
          curl -sSLo matches/atp_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2023.csv
          curl -sSLo matches/atp_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2024.csv
          curl -sSLo matches/atp_matches_2025.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2025.csv || true
          curl -sSLo matches/wta_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2023.csv
          curl -sSLo matches/wta_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2024.csv
          curl -sSLo matches/wta_matches_2025.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2025.csv || true

      - name: Generate Elo
        run: |
          python - <<'PY'
          import pandas as pd, glob, os
          START, K = 1500, 32
          def exp(a,b): return 1/(1+10**((b-a)/400))
          def upd(a,b,s): return a + K*(s-exp(a,b))
          def calc(pattern):
              files = sorted(glob.glob(pattern))
              if not files: raise SystemExit(f"No files for {pattern}")
              df = pd.concat((pd.read_csv(f) for f in files), ignore_index=True)
              E={}
              for _,r in df.iterrows():
                  w,l = r.get('winner_name'), r.get('loser_name')
                  if pd.isna(w) or pd.isna(l): continue
                  ew, el = E.get(w,START), E.get(l,START)
                  E[w] = upd(ew,el,1); E[l] = upd(el,ew,0)
              return pd.DataFrame([{'player':k,'elo':v} for k,v in E.items()]).sort_values('elo',ascending=False)
          os.makedirs("data", exist_ok=True)
          calc("matches/atp_matches_*.csv").to_csv("data/atp_elo.csv", index=False)
          calc("matches/wta_matches_*.csv").to_csv("data/wta_elo.csv", index=False)
          print("Elo ready.")
          PY

      # --- run your model with a strict 24h window (expects value_picks_pro.csv) ---
      - name: Run model (24h)
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          set -euo pipefail
          python tennis_value_picks_pro.py --region eu --lookahead-h 24 --out value_picks_pro.csv

      # --- Print shortlist using: Edge â†’ Odds band â†’ Kelly, YES/NO bet, no artifact ---
      - name: Print shortlist (criteria)
        run: |
          python - <<'PY'
          import pandas as pd, os, sys, math
          from datetime import datetime, timedelta, timezone

          # ----- Tunables from our agreed framework -----
          ODDS_FAV_MIN, ODDS_FAV_MAX = 1.30, 1.80
          ODDS_DOG_MIN, ODDS_DOG_MAX = 2.20, 4.50
          EDGE_MIN_PP = 0.03           # p_sane - p_mkt (percentage points)
          EV_MIN_PER_UNIT = 0.015      # >= 1.5%
          BET_KELLY_MIN_DOG = 0.05
          BET_KELLY_MIN_FAV = 0.02

          if not os.path.exists("value_picks_pro.csv"):
              print("No value_picks_pro.csv produced â€” skipping shortlist.")
              sys.exit(0)

          df = pd.read_csv("value_picks_pro.csv")

          # Normalize types
          num_cols = ["best_odds","blended_prob","model_prob","market_prob","ev_per_unit","kelly_fraction","confidence"]
          for c in num_cols:
              if c in df.columns: df[c] = pd.to_numeric(df[c], errors="coerce")

          # Required minimal columns
          need = {"tour","player","opponent","best_odds","blended_prob","confidence","commence_time_utc"}
          miss = [c for c in need if c not in df.columns]
          if miss:
              print("Missing columns:", ", ".join(miss)); sys.exit(0)

          # Hard 24h window (UTC)
          now = datetime.now(timezone.utc); in24 = now + timedelta(hours=24)
          df["commence_time_utc"] = pd.to_datetime(df["commence_time_utc"], utc=True, errors="coerce")
          df = df[(df["commence_time_utc"] >= now) & (df["commence_time_utc"] <= in24)]

          # Drop junk
          df = df.dropna(subset=["best_odds","blended_prob","confidence","commence_time_utc"])

          # --- price sanity: compute p_mkt (vig-free) ---
          def fair_probs_from_two(o1, o2):
              r1, r2 = 1/float(o1), 1/float(o2)
              s = r1 + r2
              if s <= 0: return None, None
              return r1/s, r2/s

          def get_p_mkt(row):
              # Best: use both sides if present
              for a,b in [("best_odds_player","best_odds_opponent"), ("best_odds","opp_best_odds")]:
                  if a in row and b in row and not (pd.isna(row[a]) or pd.isna(row[b])):
                      p_self, _ = fair_probs_from_two(row[a], row[b])
                      if p_self: return p_self, False
              # Else: use provided market_prob if present (assumed vig-free)
              if "market_prob" in row and not pd.isna(row["market_prob"]):
                  return float(row["market_prob"]), False
              # Fallback: naive implied (no vig removal)
              return 1/float(row["best_odds"]), True

          # --- model prob (use explicit model_prob if present, else blended_prob) ---
          def get_p_mdl(row):
              if "model_prob" in row and not pd.isna(row["model_prob"]):
                  return float(row["model_prob"])
              return float(row["blended_prob"])

          def kelly(p, o):
              q = 1 - p
              denom = (o - 1)
              if denom <= 0: return -1.0
              return (o*p - q)/denom

          def eta_str(t):
              delta = (t - now)
              if delta.total_seconds() < 0: return "Started"
              h = int(delta.total_seconds() // 3600)
              m = int((delta.total_seconds() % 3600) // 60)
              return f"{h}h {m}m"

          # Compute metrics row-wise
          rows=[]
          for _,r in df.iterrows():
              p_mkt, naive_flag = get_p_mkt(r)
              p_mdl = get_p_mdl(r)
              conf = float(r.get("confidence", 50.0))
              lam = max(0.0, min(1.0, (conf/100.0)**2))
              p_sane = (1-lam)*p_mkt + lam*p_mdl
              odds = float(r["best_odds"])
              ev_sane = odds*p_sane - 1
              k = kelly(p_sane, odds)
              rows.append({
                  **r.to_dict(),
                  "p_mkt": p_mkt,
                  "p_sane": p_sane,
                  "ev_sane": ev_sane,
                  "kelly_sane": k,
                  "delta_p": p_sane - p_mkt,
                  "naive_p_mkt": bool(naive_flag),
              })
          df2 = pd.DataFrame(rows)

          # Decision rule: Edge -> Odds band -> Kelly
          def band(row):
              o = row["best_odds"]
              if ODDS_FAV_MIN <= o <= ODDS_FAV_MAX: return "FAV"
              if ODDS_DOG_MIN <= o <= ODDS_DOG_MAX: return "DOG"
              return "OUT"

          def pass_filters(row):
              if row["delta_p"] < EDGE_MIN_PP: return False
              if row["ev_sane"] < EV_MIN_PER_UNIT: return False
              b = band(row)
              if b == "OUT": return False
              if b == "DOG" and row["kelly_sane"] < BET_KELLY_MIN_DOG: return False
              if b == "FAV" and row["kelly_sane"] < BET_KELLY_MIN_FAV: return False
              return True

          df2["band"] = df2.apply(band, axis=1)
          df2["bet_yes_no"] = df2.apply(lambda r: "YES" if pass_filters(r) else "NO", axis=1)

          # Helpers
          def dedup(d):
              d = d.copy()
              d.insert(0,"match_id", d.apply(lambda r: " :: ".join(sorted([str(r["player"]), str(r["opponent"])])), axis=1))
              return d.sort_values("ev_sane", ascending=False).groupby("match_id", as_index=False).first()

          def picks(data, band_label, n):
              sub = data[(data["band"]==band_label) & (data["bet_yes_no"]=="YES")]
              sub = dedup(sub).sort_values(["ev_sane","kelly_sane"], ascending=[False, False]).head(n)
              return sub

          def section(title, dfsec):
              if dfsec.empty: return "_None_"
              lines=[]
              for i,(_,r) in enumerate(dfsec.iterrows(), start=1):
                  t = r["commence_time_utc"]
                  if not pd.isna(t): t = pd.to_datetime(t, utc=True)
                  lines.append(
                      f"{i}. {r['player']} vs *{r['opponent']}* â€” **{float(r['best_odds']):.2f}** "
                      f"(p={r['p_sane']:.2f}, Î”p={r['delta_p']:.2f}, Kelly={r['kelly_sane']:.3f})\n"
                      f"   ðŸ—“ {t.strftime('%Y-%m-%d %H:%M UTC')} â€¢ ETA: {eta_str(t)}"
                  )
              return "\n".join(lines)

          # Build output
          out=[]
          for tour in ["ATP","WTA"]:
              tdf = df2[df2["tour"].str.upper()==tour]
              dogs = picks(tdf, "DOG", 3)
              favs = picks(tdf, "FAV", 2)
              out += [
                  f"## ðŸ† {tour} Underdogs (Top 3)",
                  section("dogs", dogs), "",
                  f"## ðŸ›¡ {tour} Favorites (Top 2)",
                  section("favs", favs), ""
              ]

          # Note if any naive market prob was used
          if df2["naive_p_mkt"].any():
              out += ["_Note: some p_mkt values used naive 1/odds (opponent price unavailable)._", ""]

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write("\n".join(out))
          print("Summary written.")
          PY
