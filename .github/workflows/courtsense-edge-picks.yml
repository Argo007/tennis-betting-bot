- name: Print shortlist (only qualified YES picks)
  run: |
    set -euo pipefail
    mkdir -p scripts
    cat > scripts/print_shortlist.py << 'PY'
import os, sys
import pandas as pd
from datetime import datetime, timedelta, timezone

# ---- Criteria ----
ODDS_FAV_MIN, ODDS_FAV_MAX = 1.30, 1.80
ODDS_DOG_MIN, ODDS_DOG_MAX = 2.20, 4.50
EDGE_MIN_PP = 0.03          # p_sane - p_mkt (probability points)
EV_MIN_PER_UNIT = 0.015     # >= 1.5%
BET_KELLY_MIN_DOG = 0.05
BET_KELLY_MIN_FAV = 0.02
TOP_DOGS, TOP_FAVS = 3, 2

def bail(msg):
    print(msg)
    sys.exit(0)

if not os.path.exists("value_picks_pro.csv"):
    bail("No qualified picks in the next 24h.")

df = pd.read_csv("value_picks_pro.csv")

# Normalize types
for c in ["best_odds","blended_prob","model_prob","market_prob","ev_per_unit","kelly_fraction","confidence"]:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

need = {"tour","player","opponent","best_odds","blended_prob","confidence","commence_time_utc"}
if not need.issubset(df.columns):
    bail("No qualified picks in the next 24h.")

# 24h filter
now = datetime.now(timezone.utc)
in24 = now + timedelta(hours=24)
df["commence_time_utc"] = pd.to_datetime(df["commence_time_utc"], utc=True, errors="coerce")
df = df[(df["commence_time_utc"] >= now) & (df["commence_time_utc"] <= in24)]
if df.empty:
    bail("No qualified picks in the next 24h.")
df = df.dropna(subset=["best_odds","blended_prob","confidence","commence_time_utc"])

# --- helpers ---
def fair_probs(o1, o2):
    r1, r2 = 1/float(o1), 1/float(o2)
    s = r1 + r2
    return (r1/s, r2/s) if s > 0 else (None, None)

def get_p_mkt(row, has_bp, has_bo):
    if has_bp and has_bo:
        o1, o2 = row.get("best_odds_player"), row.get("best_odds_opponent")
        if pd.notna(o1) and pd.notna(o2):
            p_self, _ = fair_probs(o1, o2)
            if p_self is not None:
                return p_self
    if "market_prob" in df.columns and pd.notna(row.get("market_prob")):
        return float(row["market_prob"])
    # Fallback: naive implied (no vig removal)
    return 1/float(row["best_odds"])

def get_p_mdl(row):
    if "model_prob" in df.columns and pd.notna(row.get("model_prob")):
        return float(row["model_prob"])
    return float(row["blended_prob"])

def kelly(p, o):
    q = 1 - p
    return (o*p - q)/(o-1) if (o-1) > 0 else -1.0

def band(o):
    if ODDS_FAV_MIN <= o <= ODDS_FAV_MAX: return "FAV"
    if ODDS_DOG_MIN <= o <= ODDS_DOG_MAX: return "DOG"
    return "OUT"

has_bp = "best_odds_player" in df.columns
has_bo = "best_odds_opponent" in df.columns

rows=[]
for _, r in df.iterrows():
    odds = float(r["best_odds"])
    p_mkt = get_p_mkt(r, has_bp, has_bo)
    p_mdl = get_p_mdl(r)
    lam = (float(r.get("confidence", 50.0))/100.0)**2
    p_sane = (1-lam)*p_mkt + lam*p_mdl
    delta_p = p_sane - p_mkt
    ev_sane = odds*p_sane - 1
    k = kelly(p_sane, odds)
    b = band(odds)

    passes = (
        (delta_p >= EDGE_MIN_PP) and
        (ev_sane >= EV_MIN_PER_UNIT) and
        (b != "OUT") and
        ((b == "DOG" and k >= BET_KELLY_MIN_DOG) or (b == "FAV" and k >= BET_KELLY_MIN_FAV))
    )
    if passes:
        rows.append({
            "tour": str(r["tour"]).upper(),
            "player": r["player"],
            "opponent": r["opponent"],
            "best_odds": odds,
            "p_sane": p_sane,
            "delta_p": delta_p,
            "kelly": k,
            "when": r["commence_time_utc"]
        })

if not rows:
    bail("No qualified picks in the next 24h.")

res = pd.DataFrame(rows)

# dedupe and order
def dedup(d):
    d = d.copy()
    d.insert(0, "match_id", d.apply(lambda x: " :: ".join(sorted([str(x["player"]), str(x["opponent"])])), axis=1))
    return d.sort_values(["delta_p","kelly"], ascending=False).groupby("match_id", as_index=False).first()

out=[]
for tour in ["ATP","WTA"]:
    t = res[res["tour"]==tour]
    if t.empty: 
        continue
    dogs = dedup(t[(t["best_odds"]>=ODDS_DOG_MIN) & (t["best_odds"]<=ODDS_DOG_MAX)]).head(TOP_DOGS)
    favs = dedup(t[(t["best_odds"]>=ODDS_FAV_MIN) & (t["best_odds"]<=ODDS_FAV_MAX)]).head(TOP_FAVS)

    if not dogs.empty:
        out.append(f"## ðŸ† {tour} Underdogs (Top {TOP_DOGS})")
        for i, (_, rr) in enumerate(dogs.iterrows(), start=1):
            out.append(
                f"{i}. {rr['player']} vs *{rr['opponent']}* â€” **{rr['best_odds']:.2f}** "
                f"(p={rr['p_sane']:.2f}, DeltaP={rr['delta_p']:.2f}, Kelly={rr['kelly']:.3f})\n"
                f"   ðŸ—“ {pd.to_datetime(rr['when']).strftime('%Y-%m-%d %H:%M UTC')}"
            )
        out.append("")

    if not favs.empty:
        out.append(f"## ðŸ›¡ {tour} Favorites (Top {TOP_FAVS})")
        for i, (_, rr) in enumerate(favs.iterrows(), start=1):
            out.append(
                f"{i}. {rr['player']} vs *{rr['opponent']}* â€” **{rr['best_odds']:.2f}** "
                f"(p={rr['p_sane']:.2f}, DeltaP={rr['delta_p']:.2f}, Kelly={rr['kelly']:.3f})\n"
                f"   ðŸ—“ {pd.to_datetime(rr['when']).strftime('%Y-%m-%d %H:%M UTC')}"
            )
        out.append("")

with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
    f.write("\n".join(out))
PY
    python scripts/print_shortlist.py
