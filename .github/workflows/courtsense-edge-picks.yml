name: CourtSense Edge Picks (Full List)

on:
  schedule:
    - cron: "0 8 * * *"   # 08:00 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: courtsense-edge-picks
  cancel-in-progress: true

env:
  TZ: Europe/Amsterdam

jobs:
  picks:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare dependencies
        run: |
          printf "pandas\nrequests\npytz\n" > requirements.txt

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: "requirements.txt"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Download ATP/WTA results
        run: |
          mkdir -p matches
          curl -sSLo matches/atp_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2023.csv
          curl -sSLo matches/atp_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2024.csv
          curl -sSLo matches/atp_matches_2025.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2025.csv || true
          curl -sSLo matches/wta_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2023.csv
          curl -sSLo matches/wta_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2024.csv
          curl -sSLo matches/wta_matches_2025.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2025.csv || true

      - name: Generate Elo
        run: |
          python - <<'PY'
          import pandas as pd, glob, os
          START, K = 1500, 32
          def exp(a,b): return 1/(1+10**((b-a)/400))
          def upd(a,b,s): return a + K*(s-exp(a,b))
          def calc(pattern):
              files = sorted(glob.glob(pattern))
              if not files: raise SystemExit(f"No files for {pattern}")
              df = pd.concat((pd.read_csv(f) for f in files), ignore_index=True)
              E={}
              for _,r in df.iterrows():
                  w,l = r.get('winner_name'), r.get('loser_name')
                  if pd.isna(w) or pd.isna(l): continue
                  ew, el = E.get(w,START), E.get(l,START)
                  E[w] = upd(ew,el,1); E[l] = upd(el,ew,0)
              return pd.DataFrame([{'player':k,'elo':v} for k,v in E.items()]).sort_values('elo',ascending=False)
          os.makedirs("data", exist_ok=True)
          calc("matches/atp_matches_*.csv").to_csv("data/atp_elo.csv", index=False)
          calc("matches/wta_matches_*.csv").to_csv("data/wta_elo.csv", index=False)
          print("Elo ready.")
          PY

      - name: Run model (24h)
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python tennis_value_picks_pro.py --region eu --lookahead-h 24 --out value_picks_pro.csv

      - name: Print all picks with YES/NO
        run: |
          python - <<'PY'
          import pandas as pd, os, sys
          from datetime import datetime, timedelta, timezone

          ODDS_FAV_MIN, ODDS_FAV_MAX = 1.30, 1.80
          ODDS_DOG_MIN, ODDS_DOG_MAX = 2.20, 4.50
          EDGE_MIN_PP = 0.03
          EV_MIN_PER_UNIT = 0.015
          BET_KELLY_MIN_DOG = 0.05
          BET_KELLY_MIN_FAV = 0.02

          if not os.path.exists("value_picks_pro.csv"):
              print("No value_picks_pro.csv produced — skipping.")
              sys.exit(0)

          df = pd.read_csv("value_picks_pro.csv")
          for c in ["best_odds","blended_prob","model_prob","market_prob","ev_per_unit","kelly_fraction","confidence"]:
              if c in df.columns: df[c] = pd.to_numeric(df[c], errors="coerce")

          need = {"tour","player","opponent","best_odds","blended_prob","confidence","commence_time_utc"}
          miss = [c for c in need if c not in df.columns]
          if miss:
              print("Missing columns:", ", ".join(miss))
              sys.exit(0)

          now = datetime.now(timezone.utc); in24 = now + timedelta(hours=24)
          df["commence_time_utc"] = pd.to_datetime(df["commence_time_utc"], utc=True, errors="coerce")
          df = df[(df["commence_time_utc"] >= now) & (df["commence_time_utc"] <= in24)]
          df = df.dropna(subset=["best_odds","blended_prob","confidence","commence_time_utc"])

          def fair_probs(o1, o2):
              r1, r2 = 1/o1, 1/o2
              s = r1 + r2
              return (r1/s, r2/s) if s > 0 else (None, None)

          def get_p_mkt(row):
              if "best_odds_player" in row and "best_odds_opponent" in row:
                  if not pd.isna(row["best_odds_player"]) and not pd.isna(row["best_odds_opponent"]):
                      p_self, _ = fair_probs(row["best_odds_player"], row["best_odds_opponent"])
                      return p_self
              if "market_prob" in row and not pd.isna(row["market_prob"]):
                  return row["market_prob"]
              return 1/row["best_odds"]

          def get_p_mdl(row):
              return row["model_prob"] if "model_prob" in row and not pd.isna(row["model_prob"]) else row["blended_prob"]

          def kelly(p, o):
              q = 1 - p
              return (o*p - q)/(o-1) if (o-1) > 0 else -1

          def band(o):
              if ODDS_FAV_MIN <= o <= ODDS_FAV_MAX: return "FAV"
              if ODDS_DOG_MIN <= o <= ODDS_DOG_MAX: return "DOG"
              return "OUT"

          def reason(row):
              if row["delta_p"] < EDGE_MIN_PP: return "Δp too small"
              if row["ev_sane"] < EV_MIN_PER_UNIT: return "EV too low"
              if row["band"] == "OUT": return "Odds out of range"
              if row["band"] == "DOG" and row["kelly_sane"] < BET_KELLY_MIN_DOG: return "Kelly too low (dog)"
              if row["band"] == "FAV" and row["kelly_sane"] < BET_KELLY_MIN_FAV: return "Kelly too low (fav)"
              return ""

          out = []
          for _,r in df.iterrows():
              p_mkt = get_p_mkt(r)
              p_mdl = get_p_mdl(r)
              conf = r["confidence"]
              lam = (conf/100)**2
              p_sane = (1-lam)*p_mkt + lam*p_mdl
              odds = r["best_odds"]
              ev_sane = odds*p_sane - 1
              k = kelly(p_sane, odds)
              delta_p = p_sane - p_mkt
              b = band(odds)
              r_dict = dict(r, p_mkt=p_mkt, p_sane=p_sane, ev_sane=ev_sane, kelly_sane=k, delta_p=delta_p, band=b)
              bet_yes = (reason(r_dict) == "")
              out.append({
                  "tour": r["tour"],
                  "player": r["player"],
                  "opponent": r["opponent"],
                  "best_odds": odds,
                  "p_sane": round(p_sane,3),
                  "delta_p": round(delta_p,3),
                  "kelly_sane": round(k,3),
                  "band": b,
                  "bet": "YES" if bet_yes else "NO",
                  "reason": reason(r_dict) if not bet_yes else "",
                  "start": r["commence_time_utc"].strftime('%Y-%m-%d %H:%M UTC')
              })

          lines = []
          for tour in ["ATP","WTA"]:
              lines.append(f"## {tour}")
              tdf = [o for o in out if o["tour"].upper() == tour]
              if not tdf:
                  lines.append("_None_")
                  continue
              for o in tdf:
                  lines.append(f"- {o['playe]()
