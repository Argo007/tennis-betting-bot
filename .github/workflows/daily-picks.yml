name: Tennis Picks (ATP/WTA)

on:
  schedule:
    - cron: "0 8 * * *"    # 08:00 UTC daily
  workflow_dispatch: {}

jobs:
  picks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests

      # --- build Elo from last two seasons (simple but effective) ---
      - name: Download ATP/WTA results
        run: |
          mkdir -p matches
          curl -sSL -o matches/atp_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2023.csv
          curl -sSL -o matches/atp_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_2024.csv
          curl -sSL -o matches/wta_matches_2023.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2023.csv
          curl -sSL -o matches/wta_matches_2024.csv https://raw.githubusercontent.com/JeffSackmann/tennis_wta/master/wta_matches_2024.csv

      - name: Generate Elo
        run: |
          python - <<'PY'
          import pandas as pd, glob, os
          START, K = 1500, 32
          def exp(a,b): return 1/(1+10**((b-a)/400))
          def upd(a,b,s): return a + K*(s-exp(a,b))
          def calc(pattern):
              files = glob.glob(pattern)
              df = pd.concat((pd.read_csv(f) for f in files), ignore_index=True)
              E = {}
              for _,r in df.iterrows():
                  w,l = r['winner_name'], r['loser_name']
                  ew, el = E.get(w,START), E.get(l,START)
                  E[w] = upd(ew,el,1); E[l] = upd(el,ew,0)
              return pd.DataFrame([{'player':k,'elo':v} for k,v in E.items()]).sort_values('elo',ascending=False)
          os.makedirs("data", exist_ok=True)
          calc("matches/atp_matches_*.csv").to_csv("data/atp_elo.csv", index=False)
          calc("matches/wta_matches_*.csv").to_csv("data/wta_elo.csv", index=False)
          print("Elo ready.")
          PY

      # --- your model: produces value_picks_pro.csv ---
      - name: Run model
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python tennis_value_picks_pro.py --region eu --lookahead-h 168 --out value_picks_pro.csv

      # --- pretty shortlist: upcoming-only (24h), Kelly-only, optional CLV ---
      - name: Print shortlist (3 Dogs, 2 Favs per tour)
        run: |
          python - <<'PY'
          import pandas as pd, os, re, datetime as dt

          # settings (keep simple inside code to avoid YAML issues)
          BUF_MIN = 5               # ignore <5m (live-ish)
          ETA_H   = 24              # only matches starting next 24h
          CLV_MIN = 0.01            # require best_odds >= 1% above consensus (if consensus exists)
          MIN_CONF = 50
          TOP_DOGS, TOP_FAVS = 3, 2
          DOG_MIN, DOG_MAX = 2.20, 4.50
          FAV_MIN, FAV_MAX = 1.30, 1.80

          now = dt.datetime.utcnow().replace(tzinfo=dt.timezone.utc)
          cut = now + dt.timedelta(minutes=BUF_MIN)
          eta_cap = now + dt.timedelta(hours=ETA_H)

          df = pd.read_csv("value_picks_pro.csv")

          # numeric coercion
          for c in ["blended_prob","best_odds","ev_per_unit","kelly_fraction","confidence"]:
              if c in df.columns:
                  df[c] = pd.to_numeric(df[c], errors="coerce")
          if "confidence" not in df.columns:
              df["confidence"] = 0

          # start time (prefer explicit UTC)
          if "commence_time_utc" in df.columns:
              df["commence_dt"] = pd.to_datetime(df["commence_time_utc"], utc=True, errors="coerce")
          elif "commence_time" in df.columns:
              df["commence_dt"] = pd.to_datetime(df["commence_time"], utc=True, errors="coerce")
          else:
              df["commence_dt"] = pd.NaT

          # remove live/in-play
          live_re = re.compile(r"(live|in[-\\s_]?play|started|progress)", re.I)
          if "is_live" in df.columns:
              df = df[~df["is_live"].fillna(False).astype(bool)]
          if "status" in df.columns:
              df = df[~df["status"].astype(str).str.contains(live_re, na=False)]

          # upcoming-only within 24h
          df = df[df["commence_dt"].notna() & (df["commence_dt"] >= cut) & (df["commence_dt"] <= eta_cap)]

          # required columns
          need = ["player","opponent","tour","best_odds","blended_prob","commence_dt"]
          if any(col not in df.columns for col in need):
              with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
                  f.write("Required columns missing in value_picks_pro.csv.\n")
              raise SystemExit(0)

          # Kelly (use provided; else compute). decimal odds
          def kelly_from(p, odds):
              if pd.isna(p) or pd.isna(odds) or odds <= 1: return 0.0
              b = odds - 1.0
              return max(0.0, (b*p - (1.0 - p))/b) if b > 0 else 0.0
          if "kelly_fraction" in df.columns and df["kelly_fraction"].notna().any():
              df["kelly"] = pd.to_numeric(df["kelly_fraction"], errors="coerce").fillna(0.0)
          else:
              df["kelly"] = [kelly_from(p, o) for p, o in zip(df["blended_prob"], df["best_odds"])]

          # Optional CLV from any extra odds columns (median consensus)
          ignore = {"best_odds","blended_prob","ev_per_unit","kelly_fraction","kelly","confidence",
                    "player","opponent","tour","commence_time_utc","commence_time","commence_dt","status","is_live"}
          cand = [c for c in df.columns if c not in ignore and ("odds" in c.lower() or "price" in c.lower() or "bk_" in c.lower())]
          clv_used = False
          if cand:
              num_cols = []
              for c in cand:
                  try:
                      df[c] = pd.to_numeric(df[c], errors="coerce")
                      if df[c].notna().any(): num_cols.append(c)
                  except: pass
              if num_cols:
                  df["consensus_odds"] = df[num_cols].median(axis=1, skipna=True)
                  if df["consensus_odds"].notna().any():
                      df["clv_edge"] = (df["best_odds"] - df["consensus_odds"]) / df["consensus_odds"]
                      df = df[df["clv_edge"].notna() & (df["clv_edge"] >= CLV_MIN)]
                      clv_used = True

          # ranking (EV/u only for ordering if missing; not displayed)
          if "ev_per_unit" not in df.columns or df["ev_per_unit"].isna().all():
              df["ev_per_unit"] = df["best_odds"]*df["blended_prob"] - 1.0

          # dedupe per match
          df["match_id"] = df.apply(lambda r: " :: ".join(sorted([str(r["player"]), str(r["opponent"])])), axis=1)
          df = df.sort_values(["ev_per_unit","confidence","commence_dt"], ascending=[False, False, True]).groupby("match_id", as_index=False).first()

          # formatting helpers
          df["eta_min"] = (df["commence_dt"] - now).dt.total_seconds()/60.0
          def eta_fmt(m): 
              m = int(round(m)); h,mm = divmod(m,60)
              return f"{h}h {mm:02d}m" if h else f"{mm}m"
          def ts_fmt(ts): return ts.strftime("%Y-%m-%d %H:%M UTC")

          def section(title, picks_md):
              return f"## ðŸŽ¾ **{title}**\n\n{picks_md}\n"

          def list_block(x):
              if x.empty: return "_None_"
              lines=[]
              for i,(_,r) in enumerate(x.iterrows(), start=1):
                  ln = (
                      f"{i}. **{r['player']}** vs *{r['opponent']}* â€” **{r['best_odds']:.2f}** "
                      f"_(p={r['blended_prob']:.2f}, Kelly={r['kelly']:.3f}"
                  )
                  if 'clv_edge' in r and pd.notna(r['clv_edge']):
                      ln += f", CLV=+{r['clv_edge']*100:.1f}%"
                  ln += f")_\n   ðŸ—“ **{ts_fmt(r['commence_dt'])}** â€¢ ETA: {eta_fmt(r['eta_min'])}"
                  lines.append(ln)
              return "\n".join(lines)

          def picks(sub, lo, hi, n):
              f = sub[(sub["best_odds"].between(lo, hi)) & (sub["confidence"].fillna(0) >= MIN_CONF)]
              return f.sort_values(["ev_per_unit","eta_min"], ascending=[False, True]).head(n)

          header = f"_Filtered at {now.strftime('%Y-%m-%d %H:%M UTC')} Â· upcoming-only (â‰¤ {ETA_H}h, buffer {BUF_MIN}m)._"
          header += f" _CLV â‰¥ {int(CLV_MIN*100)}% applied._" if clv_used else " _CLV check skipped (no consensus columns)._"
          out = [header, ""]

          for tour in ["ATP","WTA"]:
              sub = df[df["tour"].astype(str).str.upper()==tour]
              out.append(section(f"{tour} Underdogs (Top {TOP_DOGS})", list_block(picks(sub, DOG_MIN, DOG_MAX, TOP_DOGS))))
              out.append(section(f"{tour} Favorites (Top {TOP_FAVS})",   list_block(picks(sub, FAV_MIN, FAV_MAX, TOP_FAVS))))

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write("\n".join(out))
          PY
