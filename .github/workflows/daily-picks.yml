name: Daily Tennis Picks (ATP + WTA)

on:
  schedule:
    - cron: "0 8 * * *"    # auto: 08:00 UTC daily
  workflow_dispatch: {}     # manual: run anytime for fresh odds

jobs:
  picks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests

      - name: Print ATP/WTA shortlists (safe Kelly ranges)
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python - <<'PY'
          import os, math, requests, pandas as pd

          # --- config ---
          API_KEY = os.getenv("ODDS_API_KEY")
          if not API_KEY:
              raise SystemExit("ERROR: Missing ODDS_API_KEY secret (Repo ‚Üí Settings ‚Üí Secrets ‚Üí Actions).")

          REGIONS = "eu,us"          # include more books for depth
          FAV_MIN, FAV_MAX = 1.30, 1.70
          DOG_MIN, DOG_MAX = 2.40, 3.50
          MIN_KELLY = 0.01
          KELLY_CAP = 0.25
          # ---------------

          def implied_prob(o):
              o = float(o)
              return 1.0/o if o > 1.0 else None

          def ev_kelly(p, o):
              o = float(o)
              ev = o*p - (1-p)
              b = o - 1.0
              k = ((b*p) - (1-p))/b if b > 0 else 0.0
              return ev, max(0.0, min(KELLY_CAP, k))

          def fetch_odds(sport_key):
              url = f"https://api.the-odds-api.com/v4/sports/{sport_key}/odds"
              params = {"apiKey": API_KEY, "regions": REGIONS, "markets": "h2h", "oddsFormat": "decimal"}
              r = requests.get(url, params=params, timeout=30)
              if r.status_code in (401, 402):
                  raise SystemExit(f"Odds API auth/usage error ({r.status_code}): {r.text}")
              if r.status_code == 404:
                  return []
              r.raise_for_status()
              return r.json()

          def rows_for(sport_key, tour_label):
              events = fetch_odds(sport_key)
              rows = []
              for ev in events:
                  a, b = ev.get("home_team"), ev.get("away_team")
                  if not a or not b:
                      continue

                  # Collect consensus probs + best odds across all books
                  probs, best = {}, {}
                  for bk in ev.get("bookmakers", []):
                      for m in bk.get("markets", []):
                          if m.get("key") != "h2h":
                              continue
                          for oc in m.get("outcomes", []):
                              nm, price = oc.get("name"), oc.get("price")
                              if not nm or not price:
                                  continue
                              ip = implied_prob(price)
                              if ip is None:
                                  continue
                              probs.setdefault(nm, []).append(ip)
                              best[nm] = max(best.get(nm, 0.0), float(price))

                  if a not in probs or b not in probs:
                      continue

                  # Consensus (avg) then renormalize to sum 1
                  avg = {k: sum(v)/len(v) for k, v in probs.items()}
                  s = sum(avg.values())
                  if s > 0:
                      avg = {k: v/s for k, v in avg.items()}

                  # Record both sides; we‚Äôll dedup later by EV
                  for player, opp in [(a, b), (b, a)]:
                      p = avg.get(player)
                      o = best.get(player, 0.0)
                      if not p or o <= 1.0:
                          continue
                      evu, k = ev_kelly(p, o)
                      rows.append({
                          "tour": tour_label,
                          "commence_time_utc": ev.get("commence_time"),
                          "player": player,
                          "opponent": opp,
                          "best_odds": o,
                          "blended_prob": p,
                          "ev_per_unit": evu,
                          "kelly_fraction": k
                      })
              return rows

          # Build combined dataframe for ATP + WTA
          all_rows = []
          all_rows += rows_for("tennis_atp", "ATP")
          all_rows += rows_for("tennis_wta", "WTA")

          if not all_rows:
              with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
                  f.write("## ATP\n_No matches/picks right now_\n\n## WTA\n_No matches/picks right now_\n")
              raise SystemExit(0)

          df = pd.DataFrame(all_rows)
          for c in ["best_odds","blended_prob","ev_per_unit","kelly_fraction"]:
              df[c] = pd.to_numeric(df[c], errors="coerce")
          df = df.dropna(subset=["best_odds","blended_prob","ev_per_unit"])

          # One side per match (keep the higher-EV side)
          df["match_id"] = df.apply(lambda r: " :: ".join(sorted([r["player"], r["opponent"]])), axis=1)
          df = df.sort_values("ev_per_unit", ascending=False).groupby("match_id", as_index=False).head(1)

          def shortlist(sub, lo, hi):
              return sub[
                  (sub["ev_per_unit"] > 0) &
                  (sub["best_odds"].between(lo, hi)) &
                  (sub["kelly_fraction"] >= MIN_KELLY)
              ].sort_values(["ev_per_unit","blended_prob"], ascending=False)

          def section(tour):
              sub = df[df["tour"] == tour].copy()
              favs = shortlist(sub, FAV_MIN, FAV_MAX)
              dogs = shortlist(sub, DOG_MIN, DOG_MAX)

              def star(label, d):
                  if d.empty: return f"**üèÜ {label}:** _None_"
                  r = d.iloc[0]
                  return (f"**üèÜ {label}:** {r['player']} vs {r['opponent']} @ {r['best_odds']:.2f} "
                          f"(p={r['blended_prob']:.2f}, EV/u={r['ev_per_unit']:.2f}, Kelly={r['kelly_fraction']:.2f})")

              def md_table(d):
                  if d.empty: return "_None_"
                  cols = ["commence_time_utc","player","opponent","best_odds","blended_prob","ev_per_unit","kelly_fraction"]
                  d = d[cols].round({"best_odds":2,"blended_prob":2,"ev_per_unit":2,"kelly_fraction":2})
                  head = "| " + " | ".join(cols) + " |\n|" + " | ".join(["---"]*len(cols)) + "|\n"
                  body = "\n".join("| " + " | ".join(map(str, row)) + " |" for row in d.values)
                  return head + body

              out = []
              out.append(f"## {tour} Picks")
              out.append(star("Top Favorite", favs))
              out.append(star("Top Underdog", dogs))
              out.append("\n**Favorites (EV-sorted)**\n"); out.append(md_table(favs))
              out.append("\n**Underdogs (EV-sorted)**\n"); out.append(md_table(dogs))
              out.append("")
              return "\n".join(out)

          summary = "\n\n".join([section("ATP"), section("WTA")])
          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write(summary)
          PY
