name: Daily Tennis Picks (ATP + WTA)

on:
  schedule:
    - cron: "0 8 * * *"
  workflow_dispatch: {}

jobs:
  picks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests
      - name: Print ATP/WTA shortlists (uniform)
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python - <<'PY'
          import os, requests, pandas as pd
          API=os.getenv("ODDS_API_KEY")
          if not API: raise SystemExit("Set ODDS_API_KEY in repo secrets.")
          REGIONS="eu,us"
          FAV_MIN,FAV_MAX=1.25,1.85
          DOG_MIN,DOG_MAX=2.10,5.00
          MIN_KELLY=0.01
          KELLY_CAP=0.25

          def ip(o): o=float(o); return 1/o if o>1 else None
          def evk(p,o):
              o=float(o); ev=o*p-(1-p); b=o-1
              k=((b*p)-(1-p))/b if b>0 else 0.0
              return ev, max(0.0, min(KELLY_CAP, k))

          def fetch(key):
              r=requests.get(f"https://api.the-odds-api.com/v4/sports/{key}/odds",
                             params={"apiKey":API,"regions":REGIONS,"markets":"h2h","oddsFormat":"decimal"},timeout=30)
              if r.status_code==404: return []
              r.raise_for_status(); return r.json()

          def rows_for(key,tour):
              rows=[]
              for ev in fetch(key):
                  a,b=ev.get("home_team"),ev.get("away_team")
                  if not a or not b: continue
                  probs,best={},{}
                  for bk in ev.get("bookmakers",[]):
                      for m in bk.get("markets",[]):
                          if m.get("key")!="h2h": continue
                          for oc in m.get("outcomes",[]):
                              nm,pr=oc.get("name"),oc.get("price")
                              if not nm or not pr: continue
                              p=ip(pr); 
                              if p is None: continue
                              probs.setdefault(nm,[]).append(p)
                              best[nm]=max(best.get(nm,0.0),float(pr))
                  if a not in probs or b not in probs: continue
                  avg={k:sum(v)/len(v) for k,v in probs.items()}
                  s=sum(avg.values()); 
                  if s>0: avg={k:v/s for k,v in avg.items()}
                  for pl,opp in [(a,b),(b,a)]:
                      p=avg.get(pl); o=best.get(pl,0.0)
                      if not p or o<=1: continue
                      evu,k=evk(p,o)
                      rows.append({"tour":tour,"commence_time_utc":ev.get("commence_time"),
                                   "player":pl,"opponent":opp,"best_odds":o,"blended_prob":p,
                                   "ev_per_unit":evu,"kelly_fraction":k})
              return rows

          data = rows_for("tennis_atp","ATP") + rows_for("tennis_wta","WTA")

          # Build DF even if empty so the layout is always identical
          cols=["tour","commence_time_utc","player","opponent","best_odds","blended_prob","ev_per_unit","kelly_fraction"]
          df = pd.DataFrame(data, columns=cols)
          for c in ["best_odds","blended_prob","ev_per_unit","kelly_fraction"]:
              df[c]=pd.to_numeric(df[c],errors="coerce")
          if not df.empty:
              df=df.dropna(subset=["best_odds","blended_prob","ev_per_unit"])
              df["match_id"]=df.apply(lambda r:" :: ".join(sorted([str(r['player']),str(r['opponent'])])),axis=1)
              df=df.sort_values("ev_per_unit",ascending=False).groupby("match_id",as_index=False).head(1)

          def shortlist(sub,lo,hi):
              if sub.empty: return sub
              return sub[(sub["ev_per_unit"]>0)&(sub["best_odds"].between(lo,hi))&(sub["kelly_fraction"]>=MIN_KELLY)] \
                      .sort_values(["ev_per_unit","blended_prob"],ascending=False)

          def section(tour):
              sub=df[df["tour"]==tour].copy()
              favs=shortlist(sub,FAV_MIN,FAV_MAX)
              dogs=shortlist(sub,DOG_MIN,DOG_MAX)
              def star(lbl,d):
                  if d.empty: return f"**üèÜ {lbl}:** _None_"
                  r=d.iloc[0]
                  return f"**üèÜ {lbl}:** {r.player} vs {r.opponent} @ {r.best_odds:.2f} (p={r.blended_prob:.2f}, EV/u={r.ev_per_unit:.2f}, Kelly={r.kelly_fraction:.2f})"
              def table(d):
                  if d.empty: return "_None_"
                  cols=["commence_time_utc","player","opponent","best_odds","blended_prob","ev_per_unit","kelly_fraction"]
                  d=d[cols].round({"best_odds":2,"blended_prob":2,"ev_per_unit":2,"kelly_fraction":2})
                  head="| "+" | ".join(cols)+" |\n|"+" | ".join(["---"]*len(cols))+"|\n"
                  body="\n".join("| "+" | ".join(map(str,row))+" |" for row in d.values)
                  return head+body
              return "\n".join([
                  f"## {tour} Picks",
                  star("Top Favorite",favs),
                  star("Top Underdog",dogs),
                  "\n**Favorites (EV-sorted)**\n", table(favs),
                  "\n**Underdogs (EV-sorted)**\n", table(dogs),
                  ""
              ])

          summary = "\n\n".join([section("ATP"), section("WTA")])
          with open(os.environ["GITHUB_STEP_SUMMARY"],"a") as f: f.write(summary)
          PY
